<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/castapp/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/castapp/MainActivity.kt" />
              <option name="originalContent" value="package com.example.castapp&#10;&#10;import android.content.ComponentName&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.media.projection.MediaProjectionManager&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import android.view.Surface&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import com.example.castapp.ui.AppSurface&#10;import com.example.castapp.ui.theme.MyApplicationTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private var receiverService: ReceiverService? = null&#10;    private var isReceiverServiceBound = false&#10;    private var pendingSurface: Surface? = null&#10;&#10;    private val mediaProjectionManager by lazy {&#10;        getSystemService(MEDIA_PROJECTION_SERVICE) as MediaProjectionManager&#10;    }&#10;&#10;    private val screenCaptureLauncher = registerForActivityResult(&#10;        ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        if (result.resultCode == RESULT_OK) {&#10;            val intent = Intent(this, SenderService::class.java).apply {&#10;                action = SenderService.ACTION_START&#10;                putExtra(SenderService.EXTRA_RESULT_CODE, result.resultCode)&#10;                putExtra(SenderService.EXTRA_RESULT_DATA, result.data)&#10;            }&#10;            startForegroundService(intent)&#10;        }&#10;    }&#10;&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            val binder = service as ReceiverService.LocalBinder&#10;            receiverService = binder.getService()&#10;            isReceiverServiceBound = true&#10;            pendingSurface?.let { surface -&gt;&#10;                receiverService?.setSurface(surface)&#10;                pendingSurface = null&#10;            }&#10;        }&#10;&#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            isReceiverServiceBound = false&#10;            receiverService = null&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        val myIp = getIpAddress()&#10;        val gatewayIp = getGatewayIpAddress()&#10;        setContent {&#10;            MyApplicationTheme {&#10;                AppSurface(&#10;                    myIp = myIp,&#10;                    gatewayIp = gatewayIp,&#10;                    onStartSend = {&#10;                        screenCaptureLauncher.launch(mediaProjectionManager.createScreenCaptureIntent())&#10;                    },&#10;                    onStartReceive = { surface -&gt;&#10;                        // Start and bind receiver service, pass gateway IP so it can connect&#10;                        val startIntent = Intent(this, ReceiverService::class.java).apply {&#10;                            putExtra(ReceiverService.EXTRA_SENDER_IP, gatewayIp)&#10;                        }&#10;                        startForegroundService(startIntent)&#10;                        bindService(startIntent, serviceConnection, BIND_AUTO_CREATE)&#10;                        if (isReceiverServiceBound) {&#10;                            receiverService?.setSurface(surface)&#10;                        } else {&#10;                            pendingSurface = surface&#10;                        }&#10;                    },&#10;                    onStopReceive = {&#10;                        pendingSurface = null&#10;                        if (isReceiverServiceBound) {&#10;                            unbindService(serviceConnection)&#10;                            isReceiverServiceBound = false&#10;                        }&#10;                        stopService(Intent(this, ReceiverService::class.java))&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        pendingSurface = null&#10;        if (isReceiverServiceBound) {&#10;            unbindService(serviceConnection)&#10;            isReceiverServiceBound = false&#10;        }&#10;        stopService(Intent(this, SenderService::class.java))&#10;        stopService(Intent(this, ReceiverService::class.java))&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.castapp&#10;&#10;import android.content.ComponentName&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.media.projection.MediaProjectionManager&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import android.view.Surface&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import com.example.castapp.ui.AppSurface&#10;import com.example.castapp.ui.theme.MyApplicationTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private var receiverService: ReceiverService? = null&#10;    private var isReceiverServiceBound = false&#10;    private var pendingSurface: Surface? = null&#10;&#10;    private val mediaProjectionManager by lazy {&#10;        getSystemService(MEDIA_PROJECTION_SERVICE) as MediaProjectionManager&#10;    }&#10;&#10;    private val screenCaptureLauncher = registerForActivityResult(&#10;        ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        if (result.resultCode == RESULT_OK) {&#10;            val intent = Intent(this, SenderService::class.java).apply {&#10;                action = SenderService.ACTION_START&#10;                putExtra(SenderService.EXTRA_RESULT_CODE, result.resultCode)&#10;                putExtra(SenderService.EXTRA_RESULT_DATA, result.data)&#10;            }&#10;            startForegroundService(intent)&#10;        }&#10;    }&#10;&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            val binder = service as ReceiverService.LocalBinder&#10;            receiverService = binder.getService()&#10;            isReceiverServiceBound = true&#10;            pendingSurface?.let { surface -&gt;&#10;                receiverService?.setSurface(surface)&#10;                pendingSurface = null&#10;            }&#10;        }&#10;&#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            isReceiverServiceBound = false&#10;            receiverService = null&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        val myIp = getIpAddress()&#10;        val gatewayIp = getGatewayIpAddress()&#10;        setContent {&#10;            MyApplicationTheme {&#10;                AppSurface(&#10;                    myIp = myIp,&#10;                    gatewayIp = gatewayIp,&#10;                    onStartSend = {&#10;                        screenCaptureLauncher.launch(mediaProjectionManager.createScreenCaptureIntent())&#10;                    },&#10;                    onStartReceive = { surface -&gt;&#10;                        // Start and bind receiver service, pass gateway IP so it can connect&#10;                        val startIntent = Intent(this, ReceiverService::class.java).apply {&#10;                            putExtra(ReceiverService.EXTRA_SENDER_IP, gatewayIp)&#10;                        }&#10;                        startForegroundService(startIntent)&#10;                        bindService(startIntent, serviceConnection, BIND_AUTO_CREATE)&#10;                        if (isReceiverServiceBound) {&#10;                            receiverService?.setSurface(surface)&#10;                        } else {&#10;                            pendingSurface = surface&#10;                        }&#10;                    },&#10;                    onStopReceive = {&#10;                        pendingSurface = null&#10;                        if (isReceiverServiceBound) {&#10;                            unbindService(serviceConnection)&#10;                            isReceiverServiceBound = false&#10;                        }&#10;                        stopService(Intent(this, ReceiverService::class.java))&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        pendingSurface = null&#10;        if (isReceiverServiceBound) {&#10;            unbindService(serviceConnection)&#10;            isReceiverServiceBound = false&#10;        }&#10;        stopService(Intent(this, SenderService::class.java))&#10;        stopService(Intent(this, ReceiverService::class.java))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/castapp/SenderService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/castapp/SenderService.kt" />
              <option name="originalContent" value="package com.example.castapp&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.hardware.display.DisplayManager&#10;import android.hardware.display.VirtualDisplay&#10;import android.media.MediaCodec&#10;import android.media.MediaCodecInfo&#10;import android.media.MediaFormat&#10;import android.media.projection.MediaProjection&#10;import android.media.projection.MediaProjectionManager&#10;import android.os.IBinder&#10;import android.util.DisplayMetrics&#10;import android.view.WindowManager&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.launch&#10;import java.io.DataOutputStream&#10;import java.io.IOException&#10;import java.net.ServerSocket&#10;import java.net.Socket&#10;&#10;class SenderService : Service() {&#10;&#10;    private var mediaProjection: MediaProjection? = null&#10;    private var virtualDisplay: VirtualDisplay? = null&#10;    private var mediaCodec: MediaCodec? = null&#10;    private var serverSocket: ServerSocket? = null&#10;    private var clientSocket: Socket? = null&#10;    private var dataOut: DataOutputStream? = null&#10;    private val serviceJob = Job()&#10;    private val serviceScope = CoroutineScope(Dispatchers.IO + serviceJob)&#10;&#10;    private lateinit var mediaProjectionManager: MediaProjectionManager&#10;&#10;    companion object {&#10;        const val ACTION_START = &quot;com.example.castapp.START_SENDER&quot;&#10;        const val ACTION_STOP = &quot;com.example.castapp.STOP_SENDER&quot;&#10;        const val EXTRA_RESULT_CODE = &quot;resultCode&quot;&#10;        const val EXTRA_RESULT_DATA = &quot;resultData&quot;&#10;        private const val NOTIFICATION_CHANNEL_ID = &quot;SenderServiceChannel&quot;&#10;        private const val NOTIFICATION_ID = 1&#10;        private const val SERVER_PORT = 8080&#10;        private const val VIDEO_WIDTH = 720&#10;        private const val VIDEO_HEIGHT = 1280&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        mediaProjectionManager =&#10;            getSystemService(MEDIA_PROJECTION_SERVICE) as MediaProjectionManager&#10;        createNotificationChannel()&#10;        val notification = Notification.Builder(this, NOTIFICATION_CHANNEL_ID)&#10;            .setContentTitle(&quot;Screen Mirroring&quot;)&#10;            .setContentText(&quot;Sender service is running.&quot;)&#10;            .setSmallIcon(R.mipmap.ic_launcher)&#10;            .build()&#10;        startForeground(NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        when (intent?.action) {&#10;            ACTION_START -&gt; startScreenSharing(intent)&#10;            ACTION_STOP -&gt; stopScreenSharing()&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun startScreenSharing(intent: Intent) {&#10;        val resultCode = intent.getIntExtra(EXTRA_RESULT_CODE, -1)&#10;        val resultData = intent.getParcelableExtra&lt;Intent&gt;(EXTRA_RESULT_DATA)&#10;        mediaProjection = mediaProjectionManager.getMediaProjection(resultCode, resultData!!)&#10;&#10;        setupVirtualDisplay()&#10;        setupMediaCodec()&#10;        startSocketServer()&#10;    }&#10;&#10;    private fun setupVirtualDisplay() {&#10;        val metrics = DisplayMetrics()&#10;        val windowManager = getSystemService(Context.WINDOW_SERVICE) as WindowManager&#10;        windowManager.defaultDisplay.getMetrics(metrics)&#10;&#10;        val inputSurface = mediaCodec?.createInputSurface()&#10;        virtualDisplay = mediaProjection?.createVirtualDisplay(&#10;            &quot;SenderDisplay&quot;,&#10;            VIDEO_WIDTH,&#10;            VIDEO_HEIGHT,&#10;            metrics.densityDpi,&#10;            DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC,&#10;            inputSurface,&#10;            null,&#10;            null&#10;        )&#10;    }&#10;&#10;    private fun setupMediaCodec() {&#10;        val format = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_AVC, VIDEO_WIDTH, VIDEO_HEIGHT)&#10;        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)&#10;        format.setInteger(MediaFormat.KEY_BIT_RATE, 6000000)&#10;        format.setInteger(MediaFormat.KEY_FRAME_RATE, 30)&#10;        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1)&#10;&#10;        mediaCodec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC)&#10;        mediaCodec?.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)&#10;        mediaCodec?.start()&#10;    }&#10;&#10;    private fun startSocketServer() {&#10;        serviceScope.launch {&#10;            try {&#10;                serverSocket = ServerSocket(SERVER_PORT)&#10;                clientSocket = serverSocket?.accept()&#10;                dataOut = DataOutputStream(clientSocket?.getOutputStream())&#10;&#10;                val bufferInfo = MediaCodec.BufferInfo()&#10;                while (true) {&#10;                    val outputBufferId = mediaCodec?.dequeueOutputBuffer(bufferInfo, 10000) ?: -1&#10;                    if (outputBufferId &gt;= 0) {&#10;                        val encodedData = mediaCodec?.getOutputBuffer(outputBufferId)&#10;                        val chunk = ByteArray(bufferInfo.size)&#10;                        encodedData?.get(chunk)&#10;                        dataOut?.writeInt(bufferInfo.size)&#10;                        dataOut?.write(chunk)&#10;                        mediaCodec?.releaseOutputBuffer(outputBufferId, false)&#10;                    }&#10;                }&#10;            } catch (e: IOException) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScreenSharing() {&#10;        serviceScope.launch {&#10;            try {&#10;                dataOut?.close()&#10;                clientSocket?.close()&#10;                serverSocket?.close()&#10;            } catch (e: IOException) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;        mediaCodec?.stop()&#10;        mediaCodec?.release()&#10;        virtualDisplay?.release()&#10;        mediaProjection?.stop()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        stopScreenCapture()&#10;        serviceJob.cancel()&#10;        try {&#10;            dataOut?.close()&#10;            clientSocket?.close()&#10;            serverSocket?.close()&#10;        } catch (e: IOException) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    private fun stopScreenCapture() {&#10;        virtualDisplay?.release()&#10;        mediaCodec?.stop()&#10;        mediaCodec?.release()&#10;        mediaProjection?.stop()&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    private fun createNotificationChannel() {&#10;        val channel = NotificationChannel(&#10;            NOTIFICATION_CHANNEL_ID,&#10;            &quot;Sender Service Channel&quot;,&#10;            NotificationManager.IMPORTANCE_DEFAULT&#10;        )&#10;        val manager = getSystemService(NotificationManager::class.java)&#10;        manager.createNotificationChannel(channel)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.castapp&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.hardware.display.DisplayManager&#10;import android.hardware.display.VirtualDisplay&#10;import android.media.MediaCodec&#10;import android.media.MediaCodecInfo&#10;import android.media.MediaFormat&#10;import android.media.projection.MediaProjection&#10;import android.media.projection.MediaProjectionManager&#10;import android.os.IBinder&#10;import android.util.DisplayMetrics&#10;import android.view.WindowManager&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.launch&#10;import java.io.DataOutputStream&#10;import java.io.IOException&#10;import java.net.ServerSocket&#10;import java.net.Socket&#10;&#10;class SenderService : Service() {&#10;&#10;    private var mediaProjection: MediaProjection? = null&#10;    private var virtualDisplay: VirtualDisplay? = null&#10;    private var mediaCodec: MediaCodec? = null&#10;    private var serverSocket: ServerSocket? = null&#10;    private var clientSocket: Socket? = null&#10;    private var dataOut: DataOutputStream? = null&#10;    private val serviceJob = Job()&#10;    private val serviceScope = CoroutineScope(Dispatchers.IO + serviceJob)&#10;&#10;    private lateinit var mediaProjectionManager: MediaProjectionManager&#10;&#10;    companion object {&#10;        const val ACTION_START = &quot;com.example.castapp.START_SENDER&quot;&#10;        const val ACTION_STOP = &quot;com.example.castapp.STOP_SENDER&quot;&#10;        const val EXTRA_RESULT_CODE = &quot;resultCode&quot;&#10;        const val EXTRA_RESULT_DATA = &quot;resultData&quot;&#10;        private const val NOTIFICATION_CHANNEL_ID = &quot;SenderServiceChannel&quot;&#10;        private const val NOTIFICATION_ID = 1&#10;        private const val SERVER_PORT = 8080&#10;        private const val VIDEO_WIDTH = 720&#10;        private const val VIDEO_HEIGHT = 1280&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        mediaProjectionManager =&#10;            getSystemService(MEDIA_PROJECTION_SERVICE) as MediaProjectionManager&#10;        createNotificationChannel()&#10;        val notification = Notification.Builder(this, NOTIFICATION_CHANNEL_ID)&#10;            .setContentTitle(&quot;Screen Mirroring&quot;)&#10;            .setContentText(&quot;Sender service is running.&quot;)&#10;            .setSmallIcon(R.mipmap.ic_launcher)&#10;            .build()&#10;        startForeground(NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        when (intent?.action) {&#10;            ACTION_START -&gt; startScreenSharing(intent)&#10;            ACTION_STOP -&gt; stopScreenSharing()&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun startScreenSharing(intent: Intent) {&#10;        val resultCode = intent.getIntExtra(EXTRA_RESULT_CODE, -1)&#10;        val resultData = intent.getParcelableExtra&lt;Intent&gt;(EXTRA_RESULT_DATA)&#10;        mediaProjection = mediaProjectionManager.getMediaProjection(resultCode, resultData!!)&#10;&#10;        setupVirtualDisplay()&#10;        setupMediaCodec()&#10;        startSocketServer()&#10;    }&#10;&#10;    private fun setupVirtualDisplay() {&#10;        val metrics = DisplayMetrics()&#10;        val windowManager = getSystemService(Context.WINDOW_SERVICE) as WindowManager&#10;        windowManager.defaultDisplay.getMetrics(metrics)&#10;&#10;        val inputSurface = mediaCodec?.createInputSurface()&#10;        virtualDisplay = mediaProjection?.createVirtualDisplay(&#10;            &quot;SenderDisplay&quot;,&#10;            VIDEO_WIDTH,&#10;            VIDEO_HEIGHT,&#10;            metrics.densityDpi,&#10;            DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC,&#10;            inputSurface,&#10;            null,&#10;            null&#10;        )&#10;    }&#10;&#10;    private fun setupMediaCodec() {&#10;        val format = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_AVC, VIDEO_WIDTH, VIDEO_HEIGHT)&#10;        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)&#10;        format.setInteger(MediaFormat.KEY_BIT_RATE, 6000000)&#10;        format.setInteger(MediaFormat.KEY_FRAME_RATE, 30)&#10;        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1)&#10;&#10;        mediaCodec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC)&#10;        mediaCodec?.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)&#10;        mediaCodec?.start()&#10;    }&#10;&#10;    private fun startSocketServer() {&#10;        serviceScope.launch {&#10;            try {&#10;                serverSocket = ServerSocket(SERVER_PORT)&#10;                clientSocket = serverSocket?.accept()&#10;                dataOut = DataOutputStream(clientSocket?.getOutputStream())&#10;&#10;                val bufferInfo = MediaCodec.BufferInfo()&#10;                while (true) {&#10;                    val outputBufferId = mediaCodec?.dequeueOutputBuffer(bufferInfo, 10000) ?: -1&#10;                    if (outputBufferId &gt;= 0) {&#10;                        val encodedData = mediaCodec?.getOutputBuffer(outputBufferId)&#10;                        val chunk = ByteArray(bufferInfo.size)&#10;                        encodedData?.get(chunk)&#10;                        dataOut?.writeInt(bufferInfo.size)&#10;                        dataOut?.write(chunk)&#10;                        mediaCodec?.releaseOutputBuffer(outputBufferId, false)&#10;                    }&#10;                }&#10;            } catch (e: IOException) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScreenSharing() {&#10;        serviceScope.launch {&#10;            try {&#10;                dataOut?.close()&#10;                clientSocket?.close()&#10;                serverSocket?.close()&#10;            } catch (e: IOException) {&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;        mediaCodec?.stop()&#10;        mediaCodec?.release()&#10;        virtualDisplay?.release()&#10;        mediaProjection?.stop()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        stopScreenCapture()&#10;        serviceJob.cancel()&#10;        try {&#10;            dataOut?.close()&#10;            clientSocket?.close()&#10;            serverSocket?.close()&#10;        } catch (e: IOException) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    private fun stopScreenCapture() {&#10;        virtualDisplay?.release()&#10;        mediaCodec?.stop()&#10;        mediaCodec?.release()&#10;        mediaProjection?.stop()&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    private fun createNotificationChannel() {&#10;        val channel = NotificationChannel(&#10;            NOTIFICATION_CHANNEL_ID,&#10;            &quot;Sender Service Channel&quot;,&#10;            NotificationManager.IMPORTANCE_DEFAULT&#10;        )&#10;        val manager = getSystemService(NotificationManager::class.java)&#10;        manager.createNotificationChannel(channel)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>