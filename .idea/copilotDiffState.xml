<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# 局域网投屏（热点直连，无第三方服务器）&#10;&#10;一个最小可用的 Android 屏幕镜像示例：&#10;- 发送端（A 手机）开启系统热点并运行 SenderService，作为 TCP 服务端；&#10;- 接收端（B 手机）连接该热点并运行 ReceiverService，作为 TCP 客户端；&#10;- 仅使用原生 Socket（TCP），不依赖 WebRTC、STUN/TURN/ICE 或任何第三方信令服务器。&#10;&#10;本项目使用 MediaProjection + MediaCodec(H.264) 采集/编码屏幕，并通过 TCP 实时发送到另一台手机，接收端用 MediaCodec 解码后渲染到 SurfaceView。&#10;&#10;---&#10;&#10;## 功能特性&#10;- 热点直连：A 手机开热点，B 手机连入热点即可，无需互联网、无需第三方服务器。&#10;- 原生编码/解码：&#10;  - 发送端：MediaProjection 捕获屏幕，MediaCodec 编码为 H.264。&#10;  - 接收端：MediaCodec 解码 H.264，输出到 SurfaceView。&#10;- 简单可靠的长度前缀协议：支持发送 SPS/PPS（csd-0/csd-1）和帧数据，稳定初始化解码器。&#10;- 基础错误处理：连接失败/断开时弹 Toast，不崩溃。&#10;&#10;---&#10;&#10;## 工程结构&#10;&#10;```&#10;app/src/main/java/com/example/castapp/&#10;├── MainActivity.kt            # 主界面：选择“发送屏幕 / 接收屏幕”，负责启动/绑定服务&#10;├── SenderService.kt           # 发送端：MediaProjection + MediaCodec(H.264) + TCP 服务端&#10;├── ReceiverService.kt         # 接收端：TCP 客户端 + MediaCodec 解码 + Surface 渲染&#10;├── NetworkUtil.kt             # 获取本机 IP / 网关 IP（热点网关）&#10;├── CastApp.kt                 # Application，提供全局 Context&#10;└── ui/&#10;    ├── MainScreen.kt          # Compose UI（按钮 + SurfaceView 容器）&#10;    └── theme/                 # 主题文件&#10;```&#10;&#10;Manifest 中已声明所需权限与前台服务；Gradle 已配置 Compose（Kotlin 2.0 的 Compose 编译插件）。&#10;&#10;---&#10;&#10;## 工作原理（热点 + 网关 IP）&#10;1. A 手机开启系统热点后，系统会为热点分配一个局域网网关 IP（常见是 `192.168.43.1`，具体由设备决定）。&#10;2. 本 App 的发送端在 A 手机上监听 `0.0.0.0:8080`（TCP）作为服务端。&#10;3. B 手机连入热点后，通过 `WifiManager.dhcpInfo.gateway` 获取“热点网关 IP”。&#10;4. 接收端直接连接该网关 IP 的 8080 端口，与发送端建立 TCP 连接，随后接收 H.264 数据流并解码显示。&#10;&#10;无需任何第三方服务器或互联网，完全局域网内点对点传输。&#10;&#10;---&#10;&#10;## 传输协议（简化版）&#10;- 为保证解码器能正确初始化，发送端在 MediaCodec 输出格式变更时发送 csd（SPS/PPS）：&#10;  - 发送 `int(-1)` + `int(len)` + `len` 字节的 `csd-0`（SPS）&#10;  - 发送 `int(-2)` + `int(len)` + `len` 字节的 `csd-1`（PPS）&#10;- 每一帧视频：&#10;  - 发送 `int(frameLen)` + `frameLen` 字节的 H.264 数据&#10;- 接收端：&#10;  - 先收齐 `csd-0` 和 `csd-1`，且拿到渲染 Surface 后，配置解码器并开始解码后续帧。&#10;&#10;---&#10;&#10;## 构建环境&#10;- Android Gradle Plugin: 8.4.0&#10;- Kotlin: 2.0.0（已启用 `org.jetbrains.kotlin.plugin.compose`）&#10;- Compose BOM: 2024.06.00&#10;- minSdk: 30 / targetSdk: 34&#10;&#10;&gt; 说明：Kotlin 2.0 起需要启用 Compose 编译插件，工程已按要求配置，无需额外设置 `kotlinCompilerExtensionVersion`。&#10;&#10;---&#10;&#10;## 权限说明&#10;- INTERNET：Socket 网络通信。&#10;- FOREGROUND_SERVICE / FOREGROUND_SERVICE_MEDIA_PROJECTION：前台服务和投屏前台服务类型。&#10;- ACCESS_WIFI_STATE / ACCESS_NETWORK_STATE：读取网关/网络状态。&#10;&#10;&gt; Android 13+ 建议授予通知权限（POST_NOTIFICATIONS），以确保前台服务通知稳定显示（工程未强制要求）。&#10;&#10;---&#10;&#10;## 运行步骤&#10;&#10;1) 发送端（A 手机）&#10;- 打开系统“热点”功能。&#10;- 安装并启动 App。&#10;- 点击“Send Screen”（发送屏幕），同意屏幕捕获权限。&#10;- 此时 SenderService 会启动，监听 8080 端口并等待连接。&#10;&#10;2) 接收端（B 手机）&#10;- 连接到 A 手机的热点。&#10;- 启动 App，界面会显示“Hotspot Gateway: &lt;ip&gt;”。&#10;- 点击“Receive Screen”（接收屏幕），将出现一个 SurfaceView；连接成功后显示 A 手机屏幕内容。&#10;&#10;&gt; 默认编码参数：分辨率 720x1280，30fps，~1.5Mbps，比特率和分辨率可在 `SenderService.kt` 调整（VIDEO_WIDTH/HEIGHT、KEY_BIT_RATE、KEY_FRAME_RATE 等）。&#10;&#10;---&#10;&#10;## 常见问题与排查&#10;- 接收端提示“Failed to connect to sender”&#10;  - 确认 B 手机已连接 A 手机热点。&#10;  - 确认 A 手机端已点击“Send Screen”，SenderService 正在监听。&#10;  - 某些设备的热点网关 IP 不是 192.168.43.1，App 会自动读取网关 IP；若读取异常，可考虑添加手动输入。&#10;  - 检查是否有厂商/系统限制（如 AP 隔离）。&#10;&#10;- 只有黑屏/无画面&#10;  - 首次连接时请等待 1-2 秒，接收端需要先收到 csd-0/csd-1 才能初始化解码器。&#10;  - 确认接收端 Surface 已创建（UI 需要看到 SurfaceView 显示区域）。&#10;&#10;- 画面卡顿/延迟较高&#10;  - TCP 为可靠传输，丢包重传会引入延迟；可尝试降低分辨率/码率，或后续改为 UDP 自行实现更低延迟传输。&#10;&#10;- 构建/运行问题&#10;  - 若 Gradle 版本或 Kotlin 版本不一致导致同步失败，请先执行 Gradle 同步并清理缓存再试。&#10;&#10;---&#10;&#10;## 重要限制&#10;- 仅视频画面示例，不包含音频。&#10;- 未做网络自适应/丢包处理；在弱网络下可能卡顿或累积延迟。&#10;- 未做加密/鉴权；仅用于局域网内演示，请勿在不可信网络环境使用。&#10;&#10;---&#10;&#10;## 快速构建（可选）&#10;&#10;使用 Gradle 直接构建 Debug 包：&#10;&#10;```bash&#10;./gradlew :app:assembleDebug&#10;```&#10;&#10;输出位于：`app/build/outputs/apk/debug/`。&#10;&#10;---&#10;&#10;## 后续可扩展方向&#10;- 分辨率/码率/帧率动态配置，横竖屏与方向变化适配。&#10;- UDP/RTP 传输与自定义重传策略，降低端到端延迟。&#10;- 音频采集/编码/同步播放。&#10;- 简单密钥/鉴权，提升局域网安全性。&#10;- UI 增加“手动输入 IP”与“自动重连”选项。&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/castapp/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/castapp/MainActivity.kt" />
              <option name="originalContent" value="package com.example.castapp&#10;&#10;import android.content.ComponentName&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.media.projection.MediaProjectionManager&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import android.view.Surface&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import com.example.castapp.ui.AppSurface&#10;import com.example.castapp.ui.theme.MyApplicationTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private var receiverService: ReceiverService? = null&#10;    private var isReceiverServiceBound = false&#10;    private var pendingSurface: Surface? = null&#10;&#10;    private val mediaProjectionManager by lazy {&#10;        getSystemService(MEDIA_PROJECTION_SERVICE) as MediaProjectionManager&#10;    }&#10;&#10;    private val screenCaptureLauncher = registerForActivityResult(&#10;        ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        if (result.resultCode == RESULT_OK) {&#10;            val intent = Intent(this, SenderService::class.java).apply {&#10;                action = SenderService.ACTION_START&#10;                putExtra(SenderService.EXTRA_RESULT_CODE, result.resultCode)&#10;                putExtra(SenderService.EXTRA_RESULT_DATA, result.data)&#10;            }&#10;            startForegroundService(intent)&#10;        }&#10;    }&#10;&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            val binder = service as ReceiverService.LocalBinder&#10;            receiverService = binder.getService()&#10;            isReceiverServiceBound = true&#10;            pendingSurface?.let { surface -&gt;&#10;                receiverService?.setSurface(surface)&#10;                pendingSurface = null&#10;            }&#10;        }&#10;&#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            isReceiverServiceBound = false&#10;            receiverService = null&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        val myIp = getIpAddress()&#10;        val gatewayIp = getGatewayIpAddress()&#10;        setContent {&#10;            MyApplicationTheme {&#10;                AppSurface(&#10;                    myIp = myIp,&#10;                    gatewayIp = gatewayIp,&#10;                    onStartSend = {&#10;                        screenCaptureLauncher.launch(mediaProjectionManager.createScreenCaptureIntent())&#10;                    },&#10;                    onStartReceive = { surface -&gt;&#10;                        // Start and bind receiver service, pass gateway IP so it can connect&#10;                        val startIntent = Intent(this, ReceiverService::class.java).apply {&#10;                            putExtra(ReceiverService.EXTRA_SENDER_IP, gatewayIp)&#10;                        }&#10;                        startForegroundService(startIntent)&#10;                        bindService(startIntent, serviceConnection, BIND_AUTO_CREATE)&#10;                        if (isReceiverServiceBound) {&#10;                            receiverService?.setSurface(surface)&#10;                        } else {&#10;                            pendingSurface = surface&#10;                        }&#10;                    },&#10;                    onStopReceive = {&#10;                        pendingSurface = null&#10;                        if (isReceiverServiceBound) {&#10;                            unbindService(serviceConnection)&#10;                            isReceiverServiceBound = false&#10;                        }&#10;                        stopService(Intent(this, ReceiverService::class.java))&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        pendingSurface = null&#10;        if (isReceiverServiceBound) {&#10;            unbindService(serviceConnection)&#10;            isReceiverServiceBound = false&#10;        }&#10;        stopService(Intent(this, SenderService::class.java))&#10;        stopService(Intent(this, ReceiverService::class.java))&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.castapp&#10;&#10;import android.content.ComponentName&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.media.projection.MediaProjectionManager&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import android.view.Surface&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import com.example.castapp.ui.AppSurface&#10;import com.example.castapp.ui.theme.MyApplicationTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private var receiverService: ReceiverService? = null&#10;    private var isReceiverServiceBound = false&#10;    private var pendingSurface: Surface? = null&#10;&#10;    private val mediaProjectionManager by lazy {&#10;        getSystemService(MEDIA_PROJECTION_SERVICE) as MediaProjectionManager&#10;    }&#10;&#10;    private val screenCaptureLauncher = registerForActivityResult(&#10;        ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        if (result.resultCode == RESULT_OK) {&#10;            val intent = Intent(this, SenderService::class.java).apply {&#10;                action = SenderService.ACTION_START&#10;                putExtra(SenderService.EXTRA_RESULT_CODE, result.resultCode)&#10;                putExtra(SenderService.EXTRA_RESULT_DATA, result.data)&#10;            }&#10;            startForegroundService(intent)&#10;        }&#10;    }&#10;&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            val binder = service as ReceiverService.LocalBinder&#10;            receiverService = binder.getService()&#10;            isReceiverServiceBound = true&#10;            pendingSurface?.let { surface -&gt;&#10;                receiverService?.setSurface(surface)&#10;                pendingSurface = null&#10;            }&#10;        }&#10;&#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            isReceiverServiceBound = false&#10;            receiverService = null&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        val myIp = getIpAddress()&#10;        val gatewayIp = getGatewayIpAddress()&#10;        setContent {&#10;            MyApplicationTheme {&#10;                AppSurface(&#10;                    myIp = myIp,&#10;                    gatewayIp = gatewayIp,&#10;                    onStartSend = {&#10;                        screenCaptureLauncher.launch(mediaProjectionManager.createScreenCaptureIntent())&#10;                    },&#10;                    onStartReceive = { surface -&gt;&#10;                        // Start and bind receiver service, pass gateway IP so it can connect&#10;                        val startIntent = Intent(this, ReceiverService::class.java).apply {&#10;                            putExtra(ReceiverService.EXTRA_SENDER_IP, gatewayIp)&#10;                        }&#10;                        startForegroundService(startIntent)&#10;                        bindService(startIntent, serviceConnection, BIND_AUTO_CREATE)&#10;                        if (isReceiverServiceBound) {&#10;                            receiverService?.setSurface(surface)&#10;                        } else {&#10;                            pendingSurface = surface&#10;                        }&#10;                    },&#10;                    onStopReceive = {&#10;                        pendingSurface = null&#10;                        if (isReceiverServiceBound) {&#10;                            unbindService(serviceConnection)&#10;                            isReceiverServiceBound = false&#10;                        }&#10;                        stopService(Intent(this, ReceiverService::class.java))&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        pendingSurface = null&#10;        if (isReceiverServiceBound) {&#10;            unbindService(serviceConnection)&#10;            isReceiverServiceBound = false&#10;        }&#10;        stopService(Intent(this, SenderService::class.java))&#10;        stopService(Intent(this, ReceiverService::class.java))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/castapp/SenderService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/castapp/SenderService.kt" />
              <option name="originalContent" value="package com.example.castapp&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.hardware.display.DisplayManager&#10;import android.hardware.display.VirtualDisplay&#10;import android.media.MediaCodec&#10;import android.media.MediaCodecInfo&#10;import android.media.MediaFormat&#10;import android.media.projection.MediaProjection&#10;import android.media.projection.MediaProjectionManager&#10;import android.os.IBinder&#10;import android.util.DisplayMetrics&#10;import android.view.WindowManager&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import java.io.DataOutputStream&#10;import java.io.IOException&#10;import java.net.ServerSocket&#10;import java.net.Socket&#10;&#10;class SenderService : Service() {&#10;&#10;    private var mediaProjection: MediaProjection? = null&#10;    private var virtualDisplay: VirtualDisplay? = null&#10;    private var mediaCodec: MediaCodec? = null&#10;    private var serverSocket: ServerSocket? = null&#10;    private var clientSocket: Socket? = null&#10;    private var dataOut: DataOutputStream? = null&#10;    private val serviceJob = Job()&#10;    private val serviceScope = CoroutineScope(Dispatchers.IO + serviceJob)&#10;&#10;    private lateinit var mediaProjectionManager: MediaProjectionManager&#10;&#10;    companion object {&#10;        const val ACTION_START = &quot;com.example.castapp.START_SENDER&quot;&#10;        const val ACTION_STOP = &quot;com.example.castapp.STOP_SENDER&quot;&#10;        const val EXTRA_RESULT_CODE = &quot;resultCode&quot;&#10;        const val EXTRA_RESULT_DATA = &quot;resultData&quot;&#10;        private const val NOTIFICATION_CHANNEL_ID = &quot;SenderServiceChannel&quot;&#10;        private const val NOTIFICATION_ID = 1&#10;        private const val SERVER_PORT = 8080&#10;        private const val VIDEO_WIDTH = 720&#10;        private const val VIDEO_HEIGHT = 1280&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        mediaProjectionManager = getSystemService(Context.MEDIA_PROJECTION_SERVICE) as MediaProjectionManager&#10;        createNotificationChannel()&#10;        val notification = Notification.Builder(this, NOTIFICATION_CHANNEL_ID)&#10;            .setContentTitle(&quot;Screen Mirroring&quot;)&#10;            .setContentText(&quot;Sender service is running.&quot;)&#10;            .setSmallIcon(R.mipmap.ic_launcher)&#10;            .build()&#10;        startForeground(NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        when (intent?.action) {&#10;            ACTION_START -&gt; {&#10;                val resultCode = intent.getIntExtra(EXTRA_RESULT_CODE, -1)&#10;                val resultData = intent.getParcelableExtra&lt;Intent&gt;(EXTRA_RESULT_DATA)&#10;                if (resultCode != -1 &amp;&amp; resultData != null) {&#10;                    serviceScope.launch {&#10;                        startScreenCapture(resultCode, resultData)&#10;                        startServer()&#10;                    }&#10;                }&#10;            }&#10;            ACTION_STOP -&gt; stopSelf()&#10;        }&#10;        return START_NOT_STICKY&#10;    }&#10;&#10;    private fun startServer() {&#10;        try {&#10;            serverSocket = ServerSocket(SERVER_PORT)&#10;            clientSocket = serverSocket?.accept()&#10;            dataOut = DataOutputStream(clientSocket?.getOutputStream())&#10;            mediaCodec?.start()&#10;            serviceScope.launch { sendDataLoop() }&#10;        } catch (e: IOException) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    private fun startScreenCapture(resultCode: Int, data: Intent) {&#10;        mediaProjection = mediaProjectionManager.getMediaProjection(resultCode, data)&#10;&#10;        val metrics = DisplayMetrics()&#10;        val windowManager = getSystemService(Context.WINDOW_SERVICE) as WindowManager&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        windowManager.defaultDisplay.getMetrics(metrics)&#10;&#10;        val mediaFormat = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_AVC, VIDEO_WIDTH, VIDEO_HEIGHT)&#10;        mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, 1_500_000)&#10;        mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, 30)&#10;        mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)&#10;        mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1)&#10;&#10;        try {&#10;            mediaCodec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC)&#10;            mediaCodec?.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)&#10;            val surface = mediaCodec?.createInputSurface()&#10;            virtualDisplay = mediaProjection?.createVirtualDisplay(&#10;                &quot;ScreenCapture&quot;,&#10;                VIDEO_WIDTH, VIDEO_HEIGHT, metrics.densityDpi,&#10;                DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR,&#10;                surface, null, null&#10;            )&#10;        } catch (e: IOException) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    private fun sendDataLoop() {&#10;        val codec = mediaCodec ?: return&#10;        val bufferInfo = MediaCodec.BufferInfo()&#10;        try {&#10;            while (serviceJob.isActive) {&#10;                when (val index = codec.dequeueOutputBuffer(bufferInfo, 10_000)) {&#10;                    MediaCodec.INFO_TRY_AGAIN_LATER -&gt; {}&#10;                    MediaCodec.INFO_OUTPUT_FORMAT_CHANGED -&gt; {&#10;                        // Send CSD (SPS/PPS) so receiver can configure decoder&#10;                        val fmt = codec.outputFormat&#10;                        val csd0 = fmt.getByteBuffer(&quot;csd-0&quot;)&#10;                        val csd1 = fmt.getByteBuffer(&quot;csd-1&quot;)&#10;                        if (csd0 != null &amp;&amp; csd0.remaining() &gt; 0) {&#10;                            val sps = ByteArray(csd0.remaining())&#10;                            csd0.get(sps)&#10;                            dataOut?.writeInt(-1) // tag for csd-0&#10;                            dataOut?.writeInt(sps.size)&#10;                            dataOut?.write(sps)&#10;                            dataOut?.flush()&#10;                        }&#10;                        if (csd1 != null &amp;&amp; csd1.remaining() &gt; 0) {&#10;                            val pps = ByteArray(csd1.remaining())&#10;                            csd1.get(pps)&#10;                            dataOut?.writeInt(-2) // tag for csd-1&#10;                            dataOut?.writeInt(pps.size)&#10;                            dataOut?.write(pps)&#10;                            dataOut?.flush()&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        if (index &gt;= 0) {&#10;                            val outputBuffer = codec.getOutputBuffer(index)&#10;                            if (outputBuffer != null &amp;&amp; bufferInfo.size &gt; 0) {&#10;                                outputBuffer.position(bufferInfo.offset)&#10;                                outputBuffer.limit(bufferInfo.offset + bufferInfo.size)&#10;                                val frame = ByteArray(bufferInfo.size)&#10;                                outputBuffer.get(frame)&#10;                                dataOut?.writeInt(frame.size)&#10;                                dataOut?.write(frame)&#10;                                dataOut?.flush()&#10;                            }&#10;                            codec.releaseOutputBuffer(index, false)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: IOException) {&#10;            // Socket disconnected or other IO issue: stop gracefully&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        stopScreenCapture()&#10;        serviceJob.cancel()&#10;        try {&#10;            dataOut?.close()&#10;            clientSocket?.close()&#10;            serverSocket?.close()&#10;        } catch (e: IOException) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    private fun stopScreenCapture() {&#10;        virtualDisplay?.release()&#10;        mediaCodec?.stop()&#10;        mediaCodec?.release()&#10;        mediaProjection?.stop()&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    private fun createNotificationChannel() {&#10;        val channel = NotificationChannel(&#10;            NOTIFICATION_CHANNEL_ID,&#10;            &quot;Sender Service Channel&quot;,&#10;            NotificationManager.IMPORTANCE_DEFAULT&#10;        )&#10;        val manager = getSystemService(NotificationManager::class.java)&#10;        manager.createNotificationChannel(channel)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.castapp&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.hardware.display.DisplayManager&#10;import android.hardware.display.VirtualDisplay&#10;import android.media.MediaCodec&#10;import android.media.MediaCodecInfo&#10;import android.media.MediaFormat&#10;import android.media.projection.MediaProjection&#10;import android.media.projection.MediaProjectionManager&#10;import android.os.IBinder&#10;import android.util.DisplayMetrics&#10;import android.view.WindowManager&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import java.io.DataOutputStream&#10;import java.io.IOException&#10;import java.net.ServerSocket&#10;import java.net.Socket&#10;&#10;class SenderService : Service() {&#10;&#10;    private var mediaProjection: MediaProjection? = null&#10;    private var virtualDisplay: VirtualDisplay? = null&#10;    private var mediaCodec: MediaCodec? = null&#10;    private var serverSocket: ServerSocket? = null&#10;    private var clientSocket: Socket? = null&#10;    private var dataOut: DataOutputStream? = null&#10;    private val serviceJob = Job()&#10;    private val serviceScope = CoroutineScope(Dispatchers.IO + serviceJob)&#10;&#10;    private lateinit var mediaProjectionManager: MediaProjectionManager&#10;&#10;    companion object {&#10;        const val ACTION_START = &quot;com.example.castapp.START_SENDER&quot;&#10;        const val ACTION_STOP = &quot;com.example.castapp.STOP_SENDER&quot;&#10;        const val EXTRA_RESULT_CODE = &quot;resultCode&quot;&#10;        const val EXTRA_RESULT_DATA = &quot;resultData&quot;&#10;        private const val NOTIFICATION_CHANNEL_ID = &quot;SenderServiceChannel&quot;&#10;        private const val NOTIFICATION_ID = 1&#10;        private const val SERVER_PORT = 8080&#10;        private const val VIDEO_WIDTH = 720&#10;        private const val VIDEO_HEIGHT = 1280&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        mediaProjectionManager = getSystemService(Context.MEDIA_PROJECTION_SERVICE) as MediaProjectionManager&#10;        createNotificationChannel()&#10;        val notification = Notification.Builder(this, NOTIFICATION_CHANNEL_ID)&#10;            .setContentTitle(&quot;Screen Mirroring&quot;)&#10;            .setContentText(&quot;Sender service is running.&quot;)&#10;            .setSmallIcon(R.mipmap.ic_launcher)&#10;            .build()&#10;        startForeground(NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        when (intent?.action) {&#10;            ACTION_START -&gt; {&#10;                val resultCode = intent.getIntExtra(EXTRA_RESULT_CODE, -1)&#10;                val resultData = intent.getParcelableExtra&lt;Intent&gt;(EXTRA_RESULT_DATA)&#10;                if (resultCode != -1 &amp;&amp; resultData != null) {&#10;                    serviceScope.launch {&#10;                        startScreenCapture(resultCode, resultData)&#10;                        startServer()&#10;                    }&#10;                }&#10;            }&#10;            ACTION_STOP -&gt; stopSelf()&#10;        }&#10;        return START_NOT_STICKY&#10;    }&#10;&#10;    private fun startServer() {&#10;        try {&#10;            serverSocket = ServerSocket(SERVER_PORT)&#10;            clientSocket = serverSocket?.accept()&#10;            dataOut = DataOutputStream(clientSocket?.getOutputStream())&#10;            mediaCodec?.start()&#10;            serviceScope.launch { sendDataLoop() }&#10;        } catch (e: IOException) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    private fun startScreenCapture(resultCode: Int, data: Intent) {&#10;        mediaProjection = mediaProjectionManager.getMediaProjection(resultCode, data)&#10;&#10;        val metrics = DisplayMetrics()&#10;        val windowManager = getSystemService(Context.WINDOW_SERVICE) as WindowManager&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        windowManager.defaultDisplay.getMetrics(metrics)&#10;&#10;        val mediaFormat = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_AVC, VIDEO_WIDTH, VIDEO_HEIGHT)&#10;        mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, 1_500_000)&#10;        mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, 30)&#10;        mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)&#10;        mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1)&#10;&#10;        try {&#10;            mediaCodec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC)&#10;            mediaCodec?.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)&#10;            val surface = mediaCodec?.createInputSurface()&#10;            virtualDisplay = mediaProjection?.createVirtualDisplay(&#10;                &quot;ScreenCapture&quot;,&#10;                VIDEO_WIDTH, VIDEO_HEIGHT, metrics.densityDpi,&#10;                DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR,&#10;                surface, null, null&#10;            )&#10;        } catch (e: IOException) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    private fun sendDataLoop() {&#10;        val codec = mediaCodec ?: return&#10;        val bufferInfo = MediaCodec.BufferInfo()&#10;        try {&#10;            while (serviceJob.isActive) {&#10;                when (val index = codec.dequeueOutputBuffer(bufferInfo, 10_000)) {&#10;                    MediaCodec.INFO_TRY_AGAIN_LATER -&gt; {}&#10;                    MediaCodec.INFO_OUTPUT_FORMAT_CHANGED -&gt; {&#10;                        // Send CSD (SPS/PPS) so receiver can configure decoder&#10;                        val fmt = codec.outputFormat&#10;                        val csd0 = fmt.getByteBuffer(&quot;csd-0&quot;)&#10;                        val csd1 = fmt.getByteBuffer(&quot;csd-1&quot;)&#10;                        if (csd0 != null &amp;&amp; csd0.remaining() &gt; 0) {&#10;                            val sps = ByteArray(csd0.remaining())&#10;                            csd0.get(sps)&#10;                            dataOut?.writeInt(-1) // tag for csd-0&#10;                            dataOut?.writeInt(sps.size)&#10;                            dataOut?.write(sps)&#10;                            dataOut?.flush()&#10;                        }&#10;                        if (csd1 != null &amp;&amp; csd1.remaining() &gt; 0) {&#10;                            val pps = ByteArray(csd1.remaining())&#10;                            csd1.get(pps)&#10;                            dataOut?.writeInt(-2) // tag for csd-1&#10;                            dataOut?.writeInt(pps.size)&#10;                            dataOut?.write(pps)&#10;                            dataOut?.flush()&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        if (index &gt;= 0) {&#10;                            val outputBuffer = codec.getOutputBuffer(index)&#10;                            if (outputBuffer != null &amp;&amp; bufferInfo.size &gt; 0) {&#10;                                outputBuffer.position(bufferInfo.offset)&#10;                                outputBuffer.limit(bufferInfo.offset + bufferInfo.size)&#10;                                val frame = ByteArray(bufferInfo.size)&#10;                                outputBuffer.get(frame)&#10;                                dataOut?.writeInt(frame.size)&#10;                                dataOut?.write(frame)&#10;                                dataOut?.flush()&#10;                            }&#10;                            codec.releaseOutputBuffer(index, false)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: IOException) {&#10;            // Socket disconnected or other IO issue: stop gracefully&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        stopScreenCapture()&#10;        serviceJob.cancel()&#10;        try {&#10;            dataOut?.close()&#10;            clientSocket?.close()&#10;            serverSocket?.close()&#10;        } catch (e: IOException) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    private fun stopScreenCapture() {&#10;        virtualDisplay?.release()&#10;        mediaCodec?.stop()&#10;        mediaCodec?.release()&#10;        mediaProjection?.stop()&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    private fun createNotificationChannel() {&#10;        val channel = NotificationChannel(&#10;            NOTIFICATION_CHANNEL_ID,&#10;            &quot;Sender Service Channel&quot;,&#10;            NotificationManager.IMPORTANCE_DEFAULT&#10;        )&#10;        val manager = getSystemService(NotificationManager::class.java)&#10;        manager.createNotificationChannel(channel)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/castapp/ui/MainScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/castapp/ui/MainScreen.kt" />
              <option name="originalContent" value="package com.example.castapp.ui&#10;&#10;import android.view.Surface&#10;import android.view.SurfaceHolder&#10;import android.view.SurfaceView&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;&#10;@Composable&#10;fun AppSurface(&#10;    myIp: String,&#10;    gatewayIp: String,&#10;    onStartSend: () -&gt; Unit,&#10;    onStartReceive: (surface: Surface) -&gt; Unit,&#10;    onStopReceive: () -&gt; Unit&#10;) {&#10;    var receiving by remember { mutableStateOf(false) }&#10;&#10;    Surface(&#10;        modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background&#10;    ) {&#10;        if (receiving) {&#10;            DisposableEffect(Unit) {&#10;                onDispose { onStopReceive() }&#10;            }&#10;&#10;            AndroidView(&#10;                factory = { ctx -&gt;&#10;                    SurfaceView(ctx).apply {&#10;                        holder.addCallback(object : SurfaceHolder.Callback {&#10;                            override fun surfaceCreated(holder: SurfaceHolder) {&#10;                                onStartReceive(holder.surface)&#10;                            }&#10;                            override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {}&#10;                            override fun surfaceDestroyed(holder: SurfaceHolder) {}&#10;                        })&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxSize()&#10;            )&#10;        } else {&#10;            Column(&#10;                modifier = Modifier.fillMaxSize(),&#10;                verticalArrangement = Arrangement.Center,&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&quot;Your IP Address: $myIp&quot;)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Button(onClick = onStartSend) { Text(&quot;Send Screen&quot;) }&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Text(&quot;Hotspot Gateway: $gatewayIp&quot;)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Button(onClick = { if (gatewayIp.isNotBlank()) receiving = true }) {&#10;                    Text(&quot;Receive Screen&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.castapp.ui&#10;&#10;import android.view.Surface&#10;import android.view.SurfaceHolder&#10;import android.view.SurfaceView&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;&#10;@Composable&#10;fun AppSurface(&#10;    myIp: String,&#10;    gatewayIp: String,&#10;    onStartSend: () -&gt; Unit,&#10;    onStartReceive: (surface: Surface) -&gt; Unit,&#10;    onStopReceive: () -&gt; Unit&#10;) {&#10;    var receiving by remember { mutableStateOf(false) }&#10;&#10;    Surface(&#10;        modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background&#10;    ) {&#10;        if (receiving) {&#10;            DisposableEffect(Unit) {&#10;                onDispose { onStopReceive() }&#10;            }&#10;&#10;            AndroidView(&#10;                factory = { ctx -&gt;&#10;                    SurfaceView(ctx).apply {&#10;                        holder.addCallback(object : SurfaceHolder.Callback {&#10;                            override fun surfaceCreated(holder: SurfaceHolder) {&#10;                                onStartReceive(holder.surface)&#10;                            }&#10;                            override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {}&#10;                            override fun surfaceDestroyed(holder: SurfaceHolder) {}&#10;                        })&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxSize()&#10;            )&#10;        } else {&#10;            Column(&#10;                modifier = Modifier.fillMaxSize(),&#10;                verticalArrangement = Arrangement.Center,&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&quot;Your IP Address: $myIp&quot;)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Button(onClick = onStartSend) { Text(&quot;Send Screen&quot;) }&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Text(&quot;Hotspot Gateway: $gatewayIp&quot;)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Button(onClick = { if (gatewayIp.isNotBlank()) receiving = true }) {&#10;                    Text(&quot;Receive Screen&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>